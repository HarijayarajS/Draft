Content for Page 5: Insert Update Delete Operations
Alright üöÄ Let‚Äôs go into **Page 5: Insert, Update, Delete Operations** in **Tokio Postgres**. This is where trainees move from just reading data ‚Üí to actually **modifying data** in the database.

---

# üìò Page 5: Insert, Update, Delete Operations

### 1. The `execute` Method

* Used for queries that **don‚Äôt return rows** (INSERT, UPDATE, DELETE).
* Returns a `u64` ‚Üí the **number of affected rows**.
* More lightweight compared to `query` since no rows are fetched.

```rust
use tokio_postgres::{NoTls, Error};

#[tokio::main]
async fn main() -> Result<(), Error> {
    let (client, connection) = tokio_postgres::connect(
        "host=localhost user=postgres password=secret dbname=mydb",
        NoTls
    ).await?;

    // Spawn connection handling
    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("Connection error: {}", e);
        }
    });

    // INSERT example
    let rows_inserted = client
        .execute(
            "INSERT INTO users (name, email) VALUES ($1, $2)",
            &[&"Alice", &"alice@example.com"],
        )
        .await?;

    println!("Inserted rows: {}", rows_inserted);

    Ok(())
}
```

---

### 2. Using `RETURNING`

Postgres allows you to **return inserted/updated data** immediately.
Useful for getting autogenerated IDs or updated values.

```rust
let row = client
    .query_one(
        "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id",
        &[&"Bob", &"bob@example.com"],
    )
    .await?;

let id: i32 = row.get("id");
println!("New user id: {}", id);
```

üëâ This avoids running a **second query** to fetch the inserted record.

---

### 3. UPDATE Operation

Updating rows works similarly.

```rust
let updated = client
    .execute(
        "UPDATE users SET email = $1 WHERE id = $2",
        &[&"alice_new@example.com", &1],
    )
    .await?;

println!("Updated {} row(s)", updated);
```

* Always use **WHERE clauses** in UPDATE.
* Without `WHERE`, **all rows in the table get updated** üò±.

---

### 4. DELETE Operation

Deletes rows from the table.

```rust
let deleted = client
    .execute(
        "DELETE FROM users WHERE id = $1",
        &[&2],
    )
    .await?;

println!("Deleted {} row(s)", deleted);
```

‚ö†Ô∏è Same warning as UPDATE ‚Üí **always use WHERE** unless you mean to wipe the table.

---

### 5. Batch Inserts with Prepared Statements

If inserting multiple rows, prepare the statement once.

```rust
let stmt = client
    .prepare("INSERT INTO users (name, email) VALUES ($1, $2)")
    .await?;

let users = vec![
    ("Charlie", "charlie@example.com"),
    ("David", "david@example.com"),
];

for (name, email) in users {
    client.execute(&stmt, &[&name, &email]).await?;
}
```

* More efficient than preparing each time.
* Reduces network + query planning overhead.

---

### 6. Key Takeaways

* Use `execute` for `INSERT`, `UPDATE`, `DELETE`.
* Always use **parameterized queries** (`$1`, `$2`) ‚Üí prevents SQL injection.
* Use `RETURNING` for auto-generated IDs.
* Batch operations ‚Üí **prepared statements**.
* Be very careful with `UPDATE` and `DELETE` without `WHERE`.

---

üëâ Next logical step: **Transactions** (Page 6), because multiple insert/update/delete often need to be **grouped safely**.

Do you want me to continue with **Page 6: Transactions** in the same deep style?
