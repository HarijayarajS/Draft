use axum::http::Method;
use axum_test::{TestResponse, TestServer};
use serde_json::{json, Value};

// Assuming all necessary structs and functions (setup_test_server, generate_access_token, AuthTest, 
// RestDataResponse, GridFilterInput, DeviceDashboardGridFilter, etc.) are in scope, 
// as per the provided setup.
// For the purpose of this response, we'll assume the necessary imports are handled.

const DEVICE_LIST_URL: &str = "/v1/devices/list";
const TEST_ORG_ID: &str = "test-org-1";
const TEST_VENUE_ID: &str = "test-venue-1";
const TOTAL_NON_DELETED_DEVICES: u32 = 19; // Based on the existing data for test-venue-1

// Helper function to assert a list response structure
#[track_caller]
fn assert_device_list_response(res: TestResponse, expected_total: u32, expected_page_no: u32, expected_rows: usize) {
    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    res.assert_ok_data_response();
    assert_eq!(response.data.pagination.total_rows, expected_total, "Total rows mismatch");
    assert_eq!(response.data.pagination.page_no, expected_page_no, "Page number mismatch");
    assert_eq!(response.data.items.len(), expected_rows, "Number of items returned mismatch");
}

#[tokio::test]
async fn tc_1_01_invalid_token_format() {
    AuthTest::new()
        .await
        .post(DEVICE_LIST_URL)
        // Default body for a POST request that requires content
        .body(&json!({"pageNo": 1, "rowsPerPage": 25}))
        .verify_invalid_token()
        .await;
}

#[tokio::test]
async fn tc_1_02_invalid_level_org_token() {
    let input = GridFilterInput::<DeviceDashboardGridFilter> {
        page_no: 1,
        rows_per_page: 10,
        ..Default::default()
    };
    
    // The handler uses verify_venue_level(), so org-level token should fail.
    AuthTest::new()
        .await
        .post(DEVICE_LIST_URL)
        .body(&input)
        .verify_venue_level() // verify_venue_level in AuthTest is designed to test with both org (fail) and venue (pass) tokens
        .await;
}

//---

#[tokio::test]
async fn tc_1_03_successful_retrieval_default() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    // Default request: page 1, 20 rows per page (default in API), no filter/search/sort
    let input = GridFilterInput::<DeviceDashboardGridFilter> {
        page_no: 1,
        rows_per_page: 20,
        ..Default::default()
    };

    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;

    // Expected: 19 total non-deleted devices, all 19 returned on page 1
    assert_device_list_response(res, TOTAL_NON_DELETED_DEVICES, 1, 19);
}

//---

#[tokio::test]
async fn tc_1_04_filter_by_type_cashier() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    // Input to filter by type "cashier"
    let input = GridFilterInput {
        page_no: 1,
        rows_per_page: 10,
        filters: Some(DeviceDashboardGridFilter {
            r#type: Some(FilterValue { value: "cashier".to_string() }),
        }),
        ..Default::default()
    };
    
    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;
    
    // Counting 'cashier' devices in test data: 7 total (test-div-2, 4, 7, 10, 12, 15, 17)
    assert_device_list_response(res, 7, 1, 7);

    // Smart data verification: Check all returned items are of the filtered type
    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    for item in response.data.items {
        assert_eq!(item.r#type, "cashier", "Item type should be 'cashier'");
    }
}

//---

#[tokio::test]
async fn tc_1_08_keyword_search_on_name() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    // Search for "iPad" (case-insensitive)
    let input = GridFilterInput {
        page_no: 1,
        rows_per_page: 10,
        keyword: Some("iPad".to_string()), // Should match "iPad Mini 6", "iPad Pro 12.9-inch", "iPad 9th Gen", "Host Stand iPad" (4 total)
        ..Default::default()
    };
    
    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;
    
    // Expected: 4 total matches (test-div-10, 12, 17) and "Host Stand iPad"
    assert_device_list_response(res, 4, 1, 4);

    // Smart data verification: Check all returned items contain the keyword in name or type.
    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    for item in response.data.items {
        let name_lower = item.name.to_lowercase();
        let type_lower = item.r#type.to_lowercase();
        assert!(
            name_lower.contains("ipad") || type_lower.contains("ipad"),
            "Item name or type must contain 'iPad': Name={}, Type={}",
            item.name, item.r#type
        );
    }
}

//---

#[tokio::test]
async fn tc_1_11_pagination_second_page() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    // Request page 2 with 5 rows per page. Total: 19. Pages: 4.
    let input = GridFilterInput {
        page_no: 2,
        rows_per_page: 5,
        sort_key: Some("name".to_string()), // Sort by name to get a predictable order
        sort_type: Some("asc".to_string()), 
        ..Default::default()
    };
    
    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;
    
    // Expected: Total 19, Page 2, 5 items returned.
    assert_device_list_response(res, TOTAL_NON_DELETED_DEVICES, 2, 5);

    // Smart data verification: Check the first item on the second page (index 5 of the sorted list)
    // The items sorted by name ASC are:
    // 0: Backup Office POS (test-div-15)
    // 1: Bar POS Terminal (test-div-2)
    // 2: Dessert Station Printer (test-div-14)
    // 3: Drive-Thru POS 1 (test-div-7)
    // 4: Expo Station Display (test-div-6)
    // 5: Fryer Station Display (test-div-8) <- Should be the first item on page 2 (index 0 of items)
    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    assert_eq!(response.data.items[0].name, "Fryer Station Display", "First item on page 2 is incorrect after sorting by name ASC");
    assert_eq!(response.data.items[0].id, "test-div-8", "First item on page 2 ID is incorrect");
}

//---

#[tokio::test]
async fn tc_1_14_sorting_by_name_asc() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    let input = GridFilterInput {
        page_no: 1,
        rows_per_page: 19, // Enough to get all items
        sort_key: Some("name".to_string()), 
        sort_type: Some("asc".to_string()), 
        ..Default::default()
    };
    
    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;
    
    assert_device_list_response(res, TOTAL_NON_DELETED_DEVICES, 1, 19);

    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    let names: Vec<String> = response.data.items.into_iter().map(|i| i.name).collect();

    // Check the first few and last few names to confirm sorting
    // Expected sorted order (ASC):
    // Backup Office POS
    // Bar POS Terminal
    // Dessert Station Printer
    // Drive-Thru POS 1
    // ...
    // VIP Lounge Terminal
    assert_eq!(names[0], "Backup Office POS");
    assert_eq!(names[1], "Bar POS Terminal");
    assert_eq!(names[18], "VIP Lounge Terminal");
}

//---

#[tokio::test]
async fn tc_1_16_combined_filter_search_sort() {
    let server = setup_test_server().await;
    let token = generate_access_token("test-user-1", TEST_ORG_ID, Some(TEST_VENUE_ID));
    
    // Filter by type: 'cashier' (7 total)
    // Search keyword: 'POS' (Matches "Bar POS Terminal", "Drive-Thru POS 1", "Backup Office POS", "Self-Service Kiosk 1" which has "CASH" prefix)
    // Let's re-examine search: keyword search is on 'name' or 'type'. 
    // Type is already filtered to 'cashier'.
    // Cashier names: "Bar POS Terminal", "Table 5 Handheld", "Drive-Thru POS 1", "Self-Service Kiosk 1", "Host Stand iPad", "Backup Office POS", "VIP Lounge Terminal", "Poolside Handheld" (8 total in data but 7 non-deleted)
    // Non-deleted cashier devices: test-div-2, 4, 7, 10, 12, 15, 17, 20
    // Names containing 'POS' and type 'cashier': "Bar POS Terminal", "Drive-Thru POS 1", "Backup Office POS". (3 total)
    
    let input = GridFilterInput {
        page_no: 1,
        rows_per_page: 10,
        sort_key: Some("name".to_string()), 
        sort_type: Some("desc".to_string()), 
        keyword: Some("POS".to_string()),
        filters: Some(DeviceDashboardGridFilter {
            r#type: Some(FilterValue { value: "cashier".to_string() }),
        }),
        ..Default::default()
    };
    
    let res = server
        .post(DEVICE_LIST_URL)
        .authorization_bearer(token)
        .json(&input)
        .await;
    
    // Expected: 3 total rows.
    assert_device_list_response(res, 3, 1, 3);
    
    let response: RestDataResponse<GridOutput<DeviceDashboardItem>> = res.json();
    let names: Vec<String> = response.data.items.into_iter().map(|i| i.name).collect();
    
    // Expected sorted order (DESC by name):
    // Drive-Thru POS 1
    // Bar POS Terminal
    // Backup Office POS
    assert_eq!(names[0], "Drive-Thru POS 1");
    assert_eq!(names[2], "Backup Office POS");
}
